# -*- coding: utf-8 -*-
"""SOC(ECO+ML).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_BxCExQxnTXwNTPRDn8Nh7l-gb1gWSi9
"""

import random
import math

class Advertiser:
    def __init__(self, name, budget, true_valuation, ad_quality, relevance, ad_format, targeting):
        self.name = name
        self.budget = budget
        self.estimate = random.uniform(0, 10)  # Initialize the estimate with a random value
        self.num_rounds = 1
        self.true_valuation = true_valuation
        self.ad_quality = ad_quality
        self.relevance = relevance
        self.ad_format = ad_format
        self.targeting = targeting

class Publisher:
    def __init__(self, name, ad_inventory, ad_quality, relevance, ad_format, placement, targeting):
        self.name = name
        self.ad_inventory = ad_inventory
        self.ad_quality = ad_quality
        self.relevance = relevance
        self.ad_format = ad_format
        self.placement = placement
        self.targeting = targeting
        self.original_inventory = ad_inventory

class AdExchange:
    def __init__(self):
        self.advertisers = []
        self.publishers = []

    def add_publisher(self, name, ad_inventory, ad_quality, relevance, ad_format, placement, targeting):
        self.publishers.append(Publisher(name, ad_inventory, ad_quality, relevance, ad_format, placement, targeting))

    def add_advertiser(self, name, budget, true_valuation, ad_quality, relevance, ad_format, targeting):
        self.advertisers.append(Advertiser(name, budget, true_valuation, ad_quality, relevance, ad_format, targeting))

    def calculate_bid(self, advertiser, publisher):
        # UCB algorithm for exploration and LCB algorithm for exploitation
        exploration_factor = 2.0
        total_rounds = sum(a.num_rounds for a in self.advertisers)
        ucb_value = advertiser.estimate + exploration_factor * math.sqrt(math.log(total_rounds) / advertiser.num_rounds)
        lcb_value = advertiser.estimate - exploration_factor * math.sqrt(math.log(total_rounds) / advertiser.num_rounds)
        return (ucb_value + lcb_value) / 2  # Average of UCB and LCB as the bid

    def get_reward(self, advertiser, winning_price, publisher):
        # Reward function: Higher reward for bidding closer to the true valuation and other factors
        return (
            (10 - abs(winning_price - advertiser.true_valuation)) *
            advertiser.ad_quality * publisher.ad_quality *
            advertiser.relevance * publisher.relevance *
            advertiser.ad_format * publisher.ad_format *
            publisher.placement * publisher.targeting
        )

    def update_valuation(self, advertiser, reward):
        # LCB algorithm to update valuation based on the reward and convergence factor
        convergence_factor = 0.001
        learning_rate = 0.1  # Fixed learning rate for simplicity
        advertiser.estimate = (1 - learning_rate) * advertiser.estimate + learning_rate * (
                reward + convergence_factor * (advertiser.true_valuation - advertiser.estimate))
        advertiser.num_rounds += 1

    def calculate_optimal_return(self, advertiser, publisher):
        # Calculate the optimal return (maximum reward) if advertiser bids optimally
        max_reward = 0
        for bid in range(1, publisher.ad_inventory + 1):
            reward = self.get_reward(advertiser, bid, publisher)
            if reward > max_reward:
                max_reward = reward
        return max_reward

    def add_noise(self, reward):
        noise = random.uniform(0, 0.1)
        return reward + noise

    def run_auction(self, ad, rounds):
        regrets = []  # List to store regrets for each round

        for r in range(1, rounds + 1):
            round_regret = 0  # Initialize regret for this round
            for publisher in self.publishers:
                publisher.ad_inventory = publisher.original_inventory
                bids = []
                for advertiser in self.advertisers:
                    bid = self.calculate_bid(advertiser, publisher)
                    if bid > 0:
                        bids.append((advertiser, bid))

                if len(bids) > 0:
                    bids.sort(key=lambda x: x[1], reverse=True)
                    winning_bid = bids[0]
                    winning_advertiser, winning_price = winning_bid
                    if winning_price <= publisher.ad_inventory:
                        publisher.ad_inventory -= 1
                        winning_advertiser.budget -= winning_price
                        reward = self.get_reward(winning_advertiser, winning_price, publisher)
                        reward = self.add_noise(reward)  # Add noise to the reward
                        self.update_valuation(winning_advertiser, reward)
                        round_regret += self.calculate_optimal_return(winning_advertiser, publisher) - reward

            regrets.append(round_regret)
            print(f"Round {r}: Regret = {round_regret+random.uniform(-1, 1)}")

        return regrets

if __name__ == "__main__":
    ad_A = "AD_A"
    true_valuations = [8, 9, 7, 8.5, 6]

    ad_exchange = AdExchange()
    ad_exchange.add_publisher("Publisher1", ad_inventory=5, ad_quality=4, relevance=3, ad_format=4, placement=5, targeting=4)
    ad_exchange.add_publisher("Publisher2", ad_inventory=3, ad_quality=3, relevance=5, ad_format=3, placement=4, targeting=3)
    ad_exchange.add_publisher("Publisher3", ad_inventory=7, ad_quality=5, relevance=4, ad_format=5, placement=3, targeting=5)

    ad_exchange.add_advertiser("Advertiser1", budget=20, true_valuation=true_valuations[0], ad_quality=4, relevance=5, ad_format=3, targeting=4)
    ad_exchange.add_advertiser("Advertiser2", budget=15, true_valuation=true_valuations[1], ad_quality=3, relevance=4, ad_format=5, targeting=3)
    ad_exchange.add_advertiser("Advertiser3", budget=25, true_valuation=true_valuations[2], ad_quality=5, relevance=3, ad_format=4, targeting=5)
    ad_exchange.add_advertiser("Advertiser4", budget=18, true_valuation=true_valuations[3], ad_quality=4, relevance=4, ad_format=4, targeting=4)
    ad_exchange.add_advertiser("Advertiser5", budget=12, true_valuation=true_valuations[4], ad_quality=3, relevance=3, ad_format=3, targeting=3)

    regrets = ad_exchange.run_auction(ad_A, rounds=1000)

    # Print the final estimate and true valuation of the ad impression "AD_A"
    print(f"\nFinal Estimate: {ad_exchange.advertisers[0].estimate}")
    print(f"True Valuation: {ad_exchange.advertisers[0].true_valuation}")